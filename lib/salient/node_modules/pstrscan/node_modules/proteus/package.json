{
  "name": "proteus",
  "description": "A declarative way of creating objects, properties, and classes in ES5 JavaScript",
  "version": "0.1.3",
  "keywords": [
    "ooo",
    "class",
    "object",
    "properties",
    "utility"
  ],
  "main": "./node_modules/proteus/index.js",
  "devDependencies": {
    "sake": ">=0.1.x",
    "ejs": ">=0.7.x",
    "mocha": ">=1.3.x",
    "should": ">=0.6.3"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/jhamlet/proteus/raw/master/LICENSE"
    }
  ],
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jhamlet/proteus.git"
  },
  "bugs": {
    "url": "http://github.com/jhamlet/proteus/issues"
  },
  "scripts": {
    "test": "mocha ./test/test-*"
  },
  "preferGlobal": true,
  "contributors": [
    {
      "name": "Jerry Hamlet",
      "email": "jerry@hamletink.com",
      "url": "http://hamletink.com/"
    }
  ],
  "readme": "proteus\n=======\n\n> A declarative way of creating objects, properties, and classes in ES5 JavaScript\n\n### ˈprōtēəs; ˈprōˌt(y)oōs\n\n>   In Greek Mythology a minor sea god (son of Oceanus and Tethys) who had the\n>   power of prophecy but who would assume different shapes to avoid answering\n>   questions.\n\n>   From the Greek protos \"first.\"\n\nOverview\n--------\n\n**Proteus** is a little library of utility functions that I put together to help manage creating objects and implementing classical inheritance in JavaScript flavors 1.8+.\n\nObject Creation and Modification\n--------------------------------\n\n### Proteus.create(proto, props)\n\nInterface to Object.create, however, the props argument is a plain object of properties to copy over to the newly created object.  Getters and setters will be preserved.\n\n### Proteus.defineProperty(obj, name, val, [spec])\n\nUtility method for creating 'plain' properties on an object. Plain being {enumerable: true, writable: true, configurable: true}, the passed spec can override these defaults.\n\n```js\nProteus.defineProperty(obj, \"propName\", 42);\n\nProteus.defineProperty(\n    obj,\n    \"methodName\",\n    function () { /*...*/ },\n    {enumerable: false}\n);\n```\n\n### Proteus.defineProperties(obj, list)\n\nDefine multiple properties.\n\n```js\nProteus.defineProperties(obj, [\n    [obj, \"propName\", 42],\n    [obj, \"methodName\", function () {\n        /*...*/\n    }, {\n        enumerable: false\n    }]\n]);\n```\n\n### Proteus.defineGetter(obj, name, fn, [spec])\n\nUtility method for creating a getter on an object. The property definition will default to {enumerable: true, configurable: true} unless overridden with the spec object.\n\n### Proteus.defineSetter(obj, name, fn, [spec])\n\nUtility method for creating a setter on an object. The property definition will default to {enumerable: true, configurable: true} unless overridden with the spec object.\n\n### Proteus.defineGetSet(obj, name, getter, [setter], [spec])\n\nUtility method for creating both a getter and a setter on an object. The property definition will default to {enumerable: true, configurable: true} unless overridden with the spec object.\n\nif `setter` is not given, then the `getter` function will be used for both getting and setting\n\n### Proteus.getPropertyNames(obj)\n\nGet all property names for an object, all the way up the prototype chain.\n\n### Proteus.getPropertyDescriptor(obj, name)\n\nGet a property descriptor for an object where ever it may exist in the prototype chain.\n\n### Proteus.copyOwnProperties(hidden = false, overwrite = true, supplier, receiver)\n\nCopy properties from `supplier` to `receiver`. This method will preserve the property definitions from `supplier` to `receiver` (uses `Object.getOwnPropertyDescriptor` under the hood).\n\n### Proteus.copyAllProperties(supplier, receiver)\n\nCopy all properties from `supplier` to `receiver`.\n\n### Proteus.applyProperties(supplier, receiver)\n\nCopy all *enumerable* properties from `supplier` to `receiver` only if the property *does not* exist on the `receiver` object.\n\n### Proteus.applyAllProperties(supplier, receiver)\n\nCopy all properties from `supplier` to `receiver`, but do not overwrite existing properties on `receiver`.\n\n### Proteus.merge(receiver, arg1, ..., argN)\n\nMerge *enumerable* properties from all objects passed as arguments onto `receiver`.\n\n### Proteus.mergeAll(receiver, arg1, ..., argN)\n\nMerge all properties from all objects passed as arguments onto `reciever`.\n\n### Proteus.apply(receiver, arg1, ..., argN)\n\nMerge *enumerable* properties from all objects passed as arguments onto `receiver`, only if they do not exist on `receiver`.\n\n### Proteus.applyAll(receiver, arg1, ..., argN)\n\nMerge all properties from all objects passed as arguments onto `receiver`, only if they do not exist on `receiver`.\n\nProteus Utility Methods\n-----------------------\n\n<!--\n### Proteus.extend(extendee, extender1, ..., extenderN)\n\nExtend one object with the properties of another.\n\nIf the extending object (`extender1, ..., extenderN`) has a function named `extended`, it will be called with one argument, the object that was extended (`extendee`).\n\n### Proteus.include(self, obj1, ..., objN)\n\nInclude properties onto the prototype of 'self' from a *Constructor* function's prototype, or a plain object. If `obj` has a property named `self`, the properties of `self` will be merged into the passed 'self'.\n\nIf the supplying object, `obj`, has a function named `included` it will be called with one argument, the 'self' object that was just modified.\n\n### Proteus.derive(parent, props)\n\nDerive a new *Constructor* function from another, optionally adding the supplied properties to its prototype.\n\nIf the parent *Constructor* has a function named `inherited` it will be called with one argument, the new *Constructor* function.\n-->\n\n### Proteus.slice(list, offset = 0, end = list.length)\n\nReturn a portion of the *array-like* object.\n\n### Proteus.aliasMethod(name, [scope])\n\nReturn a function that is bound to call another function on the current object, or the supplied one.\n\n### Proteus.delegateMethod(obj, name, [args, ...])\n\nDelegate a function call to another object. Additional arguments will be *prepended* to the function call.\n\n### Proteus.applyProto(self, [name], args = [])\n\nApply a method from the `self` object's prototype chain.\n\nThe `name` argument is optional if the function you are invoking from, and the one up the prototype chain you wish to invoke is named. e.g:\n\n```js\nvar Proteus = require(\"proteus\"),\n    objA = {\n        someMethod: function someMethod () {\n            console.log(\"I'm object A\");\n        }\n    },\n    objB = Proteus.create(objA, {\n        someMethod: function someMethod () {\n            Proteus.applyProto(this, arguments);\n            console.log(\"I'm object B\");\n        }\n    })\n;\n\nobjB.someMethod();\n\n// => I'm object A\n// => I'm object B\n```\n\n### Proteus.callProto(self, name, [arg1], [...], [argN])\n\nCall a method `name` from the `self` object's prototype chain passing the remaining arguments as arguments.\n\n*Note:* the `name` parameter is **not** optional.\n\n\nProteus.Class\n-------------\n\n`Proteus.Class` starts off the Proteus inheritance chain (itself is a descendent of `Object`). From there you can derive new classes from `Proteus.Class` (or any classes that are derived from `Proteus.Class`) to develop your class hierarchy.\n\n```js\nvar MyClass = Proteus.Class.derive({\n        // props for MyClass\n    }),\n    MySubClass = MyClass.derive({\n        // props for MySubClass\n    })\n;\n```\n\n### Deriving Inheritance\n\n**_ProteusClass_.derive(props)**\n\nAs shown above, use the static methods on the core `Proteus.Class`, or the *Constructor* functions returned by `derive`, to derive new subclasses.\n\nIn addition, `Proteus` allows you to define static properties on your subclass' *Constructor* function. Simply provide a property `self` in the passed properties for your class, and those will be copied to the *Constructor* function instead of the *Constructor's prototype*.\n\n```js\nvar MyClass = Proteus.Class.derive({\n        self: {\n            // Static properties for 'MyClass'\n            myStaticMethod: function () {\n                return true;\n            }\n        },\n        // All other properties are put on the prototype\n        instancePropA: \"somevalue\"\n    });\n    \nMyClass.myStaticMethod(); // => true\n(new MyClass()).instancePropA === \"somevalue\"; // => true\n```\n\n#### The Inherited Event\n\nWhen one class is derived from another, and the superclass possesses a function property named `inherited`, the function will be called and passed the newly created *Constructor* function (i.e: the new subclass).\n\n```js\nvar MyBaseClass = Proteus.Class.derive({\n        self: {\n            inherited: function (subclass) {\n                subclass.superParent = \"MyBaseClass\";\n            }\n        }\n    }),\n    MySubClass = MyBaseClass.derive({/* ... */})\n;\n\nMySubClass.superParent === \"MyBaseClass\"; // => true\n```\n\n### *ProteusClass*.\\_\\_super\\_\\_ Property\n\nEvery class derived from Proteus.Class has a `__super__` property that points to its super class' prototype.\n\n```js\nvar MyBaseClass = Proteus.Class.derive({\n        someMethod: function () {\n            // ...\n        }\n    }),\n    MySubClass = MyBaseClass.derive({\n        someMethod: function () {\n            MySubClass.__super__.someMethod.call(this);\n        }\n    })\n;\n```\n\n### Including Instance Functionality\n\n**_ProteusClass_.include(obj1, ..., objN)**\n\nYou can mix-in functionality from other *Constructor* function prototype's, or plain objects, into Proteus derived classes with the `include` method.\n\nIf passed a *Constructor* function, Proteus will copy the function's prototype properties to your Class' prototype. If passed a plain object, it will copy over those properties to the prototype of the class.\n\n```js\n// Copy 'OtherClass' prototype properties to 'MyClass' prototype.\nMyClass.include(OtherClass);\n\n// Merge the passed object into 'MyClass'\nMyClass.include({\n    // Additional properties for MyClass.prototype\n});\n```\n\n#### The Included Event\n\nWhen an object, or *Constructor* function, is included into a Proteus Class its `included` function will be called and given the object that it was included into (the Proteus Class *Constructor*).\n\n```js\nvar MyModule = Proteus.Class.derive({\n        self: {\n            decorators: [],\n            included: function (includee) {\n                includee.decorators = this.decorators.slice();\n            }\n        }\n    }),\n    MyClass = Proteus.Class.derive({/* ... */})\n;\n\nMyClass.include(MyModule);\nMyClass.decorators; // => []\n```\n\n#### Extending Your Class\n\n**_ProteusClass_.extend(obj)**\n\nYou can use a *ProteusClass's* `extend` method to extend another object with its functionality.\n\n```js\nvar MyClass = Proteus.class.derive({\n        self: {\n            someMethod: function () {\n                // ...\n            }\n        }\n    });\n    \n// elsewhere\nMyClass.extend(obj);\ntypeof MyClass.someMethod; // => \"function\"\n```\n\n#### The Extended Event\n\n### Instantiation\n\nReport an Issue\n---------------\n\n* [Bugs](http://github.com/jhamlet/proteus/issues)\n* Contact the author: <jhamlet@hamletink.com>\n\n\nLicense\n-------\n\n> Copyright (c) 2012 Jerry Hamlet <jerry@hamletink.com>\n> \n> Permission is hereby granted, free of charge, to any person\n> obtaining a copy of this software and associated documentation\n> files (the \"Software\"), to deal in the Software without\n> restriction, including without limitation the rights to use,\n> copy, modify, merge, publish, distribute, sublicense, and/or sell\n> copies of the Software, and to permit persons to whom the\n> Software is furnished to do so, subject to the following\n> conditions:\n> \n> The above copyright notice and this permission notice shall be\n> included in all copies or substantial portions of the Software.\n> \n> The Software shall be used for Good, not Evil.\n> \n> THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n> EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n> OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n> NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n> HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n> WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n> FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n> OTHER DEALINGS IN THE SOFTWARE.\n\n",
  "readmeFilename": "README.md",
  "_id": "proteus@0.1.3",
  "bundleDependencies": [
    "proteus"
  ],
  "_from": "proteus@0.1.x"
}
